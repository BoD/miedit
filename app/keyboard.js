"use strict"
/**
 * @file keyboard
 * @author Frédéric BISSON <zigazou@free.fr>
 * @version 1.0
 * 
 * Keyboard simulates a Minitel keyboard from a standard keyboard.
 */

/**
 * The EmitterHandler callback handles code sequences generated by a Keyboard
 * object.
 * @name EmitterHandler
 * @function
 * @param {Int[]} sequence Minitel code sequence
 */

/**
 * Keyboard converts keys received by the browser into Minitel keys.
 */
class Keyboard {
    /**
     * @param {HTMLElement} container Element containing all keyboard elements.
     * @param {EmitterHandler} emitter An emitter handler that will be called
     *                                 everytime a key generates Minitel codes.
     */
    constructor(container, emitter) {
        /**
         * Remembers if the ctrl key is down.
         * @member {boolean}
         * @private
         */
        this.kCtrl = false

        /**
         * Remembers if the shift key is down.
         * @member {boolean}
         * @private
         */
        this.kShift = false

        /**
         * Remembers if the fnct key is down.
         * @member {boolean}
         * @private
         */
        this.kFnct = false

        /**
         * Does the keyboard works in extended mode?
         * @member {boolean}
         * @private
         */
        this.kExtended = false

        /**
         * Does the keyboard generates code for the cursor keys?
         * @member {boolean}
         * @private
         */
        this.kCursorKeys = false

        /**
         * Does the keyboard works in uppercase mode? (default mode of Minitel)
         * @member {boolean}
         * @private
         */
        this.kUppercase = true

        /**
         * The EmitterHandler associated with the keyboard.
         * @member {EmitterHandler}
         * @private
         */
        this.emitter = null

        /**
         * The alphabetical keys page.
         * @member {HTMLElement}
         * @private
         */
        this.pageAlpha = container.getElementsByClassName("page-alpha")[0]

        /**
         * The non-alphabetical keys page.
         * @member {HTMLElement}
         * @private
         */
        this.pageNAlpha = container.getElementsByClassName("page-non-alpha")[0]

        const keydown = container.getElementsByClassName(
            "minitel-standardkey-down"
        )[0]

        const keyup = container.getElementsByClassName(
            "minitel-standardkey-up"
        )[0]

        this.simulator = new KeySimulator(keydown, keyup)

        document.addEventListener("keydown", event => this.onkeydown(event))
        document.addEventListener("keyup", event => this.onkeyup(event))
        document.addEventListener("keypress", event => this.onkeypress(event))
        document.getElementsByClassName("keyboard-grid")[0].autocallback(this)
    }

    /**
     * Defines an EmitterHandler which will be called everytime a key is
     * is pressed.
     * @member {EmitterHandler}
     */
     setEmitter(emitter) {
        this.emitter = emitter
    }

    /**
     * Handles key presse events.
     * @private
     */
    keypress(keycodes) {
        if(this.emitter !== null && keycodes !== null) {
            this.emitter(keycodes)
        }
    }

    /**
     * Handles key down events.
     * @private
     */
    onkeydown(event) {
        this.simulator.pressKey(event.key)
    }

    /**
     * Handles switch button event.
     * @private
     */
    onSwitch(event) {
        if(this.pageAlpha.classList.contains("hidden")) {
            this.pageAlpha.classList.remove("hidden")
            this.pageNAlpha.classList.add("hidden")
        } else {
            this.pageNAlpha.classList.remove("hidden")
            this.pageAlpha.classList.add("hidden")
        }
    }

    /**
     * Handles key up events.
     * @private
     */
    onkeyup(event) {
        this.simulator.releaseKey(event.key)
    }

    /**
     * Handles key press events.
     * @private
     */
    onkeypress(event) {
        this.kShift = event.shiftKey
        this.keypress(this.toMinitel(event.key))
    }

    /**
     * Handles click events.
     * @private
     */
    onclick(event, param) {
        if(param === "Maj") {
            this.kShift = !this.kShift
        }

        this.keypress(this.toMinitel(param))
    }

    /**
     * Set the uppercase mode of the keyboard
     * @param {boolean} bool true indicates the keyboard operates in uppercase
     *                       false indicates the keyboard operates in lowercase
     */
    setUppercaseMode(bool) {
        this.kUppercase = bool
    }

    /**
     * Set the extended mode of the keyboard
     * @param {boolean} bool true indicates the keyboard works extended
     *                       false indicates the keyboard works standard
     */
    setExtendedMode(bool) {
        this.kExtended = bool
    }

    /**
     * Set the cursor keys of the keyboard
     * @param {boolean} bool true indicates keyboard use cursor keys
     *                       false indicates keyboard does not use cursor keys
     */
    setCursorKeys(bool) {
        this.kCursorKeys = bool
    }

    /**
     * Converts a key to a Minitel code sequence according to the current state
     * of the keyboard.
     * @param {String} key A string identifying a key.
     * @return {Int[]} The Minitel code sequence corresponding or null if the
     *                 key cannot be converted.
     */
    toMinitel(key) {
        if(key.length == 1) {
            // Handles uppercase mode and shift key
            if(this.kUppercase == !this.kShift) {
                key = key.toUpperCase()
            } else {
                key = key.toLowerCase()
            }
        }

        if(key in Minitel.keys["Videotex"]) {
            return Minitel.keys["Videotex"][key]
        }

        return null

        // Mode C0
        // Haut [ 0x0B ]
        // Bas [ 0x0A ]
        // Droite [ 0x09 ]
        // Gauche [ 0x08 ]
        // CtrlGauche [ 0x7F ]
        // Entree [ 0x0D ]
        // MajEntree [ 0x1E ]
        // CtrlEntree [ 0x0C ]

        // Mode téléinformatique
        // Envoi [ 0x1B, 0x4F, 0x4D ]
        // Sommaire [ 0x1B, 0x4F, 0x50 ]
        // Annulation [ 0x1B, 0x4F, 0x51 ]
        // Retour [ 0x1B, 0x4F, 0x52 ]
        // Repetition [ 0x1B, 0x4F, 0x53 ]
        // Correction [ 0x1B, 0x4F, 0x6C ]
        // Guide [ 0x1B, 0x4F, 0x6D ]
        // Suite [ 0x1B, 0x4F, 0x6E ]

        // F10 [ 0x1B, 0x4F, 0x70 ]
        // F1 [ 0x1B, 0x4F, 0x71 ]
        // F2 [ 0x1B, 0x4F, 0x72 ]
        // F3 [ 0x1B, 0x4F, 0x73 ]
        // F4 [ 0x1B, 0x4F, 0x74 ]
        // F5 [ 0x1B, 0x4F, 0x75 ]
        // F6 [ 0x1B, 0x4F, 0x76 ]
        // F7 [ 0x1B, 0x4F, 0x77 ]
        // F8 [ 0x1B, 0x4F, 0x78 ]
        // F9 [ 0x1B, 0x4F, 0x79 ]
        
        // Haut [ 0x1B, 0x5B, 0x41 ]
        // MajHaut [ 0x1B, 0x5B, 0x4D ]
        // Bas [ 0x1B, 0x5B, 0x42 ]
        // MajBas [ 0x1B, 0x5B, 0x4C ]
        // Droite [ 0x1B, 0x5B, 0x42 ]
        // MajDroite [ 0x1B, 0x5B, 0x34, 0x68 ] [ 0x1B, 0x5B, 0x34, 0x6C ]
        // Gauche [ 0x1B, 0x5B, 0x44 ]
        // MajGauche [ 0x1B, 0x5B, 0x50 ]
        // CtrlGauche [ 0x7F ]
        // Entree [ 0x0D ]
        // MajEntree [ 0x1B, 0x5B, 0x48 ]
        // CtrlEntree [ 0x1B, 0x5B, 0x32, 0x4A ]
    }
}
